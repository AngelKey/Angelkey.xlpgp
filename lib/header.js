// Generated by IcedCoffeeScript 1.7.1-f
(function() {
  var C, Header, iced, pack, __iced_k, __iced_k_noop;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  C = require('./const');

  pack = require('purepack').pack;

  exports.Header = Header = (function() {
    function Header(_arg) {
      this.stubs = _arg.stubs, this.keys = _arg.keys, this.hmac_block_1 = _arg.hmac_block_1;
      this._encrypted = null;
    }

    Header.prototype.generate = function(cb) {
      var buf, err, json, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      json = [C.version, this.keys.cipher.key, this.keys.cipher.iv, this.keys.hmac.key, this.hmac_block_1];
      buf = pack(json);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/xlpgp/src/header.iced",
            funcname: "Header.generate"
          });
          _this.stubs.encrypt_pgp_header({
            buf: buf
          }, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                err = arguments[0];
                return __slot_1._encrypted = arguments[1];
              };
            })(_this),
            lineno: 18
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, _this._encrypted);
        };
      })(this));
    };

    Header.prototype.set_hmac_block_1 = function(b) {
      return this.hmac_block_1 = b;
    };

    Header.prototype.to_packet = function(_arg, cb) {
      var buf, dummy, err, esc, len, pgp, pkt, to_buf_args, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      dummy = _arg.dummy;
      esc = make_esc(cb, "Header::to_packet");
      to_buf_args = {};
      (function(_this) {
        return (function(__iced_k) {
          if (dummy) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/xlpgp/src/header.iced",
                funcname: "Header.to_packet"
              });
              _this.stubs.estimate_pgp_header_length(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return len = arguments[1];
                  };
                })(),
                lineno: 31
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(_this._dummy = pgp = new Buffer((function() {
                var _i, _results;
                _results = [];
                for (_i = 0; 0 <= len ? _i < len : _i > len; 0 <= len ? _i++ : _i--) {
                  _results.push(0);
                }
                return _results;
              })()));
            });
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/xlpgp/src/header.iced",
                funcname: "Header.to_packet"
              });
              _this.generate(esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return pgp = arguments[0];
                  };
                })(),
                lineno: 34
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(_this._dummy != null ? to_buf_args.len = _this._dummy.len : void 0);
            });
          }
        });
      })(this)((function(_this) {
        return function() {
          pkt = new HeaderPacket({
            pgp: pgp,
            stubs: _this.stubs
          });
          buf = pkt.to_buffer(to_buf_args);
          return cb(null, buf);
        };
      })(this));
    };

    return Header;

  })();

}).call(this);
