// Generated by IcedCoffeeScript 1.7.1-f
(function() {
  var C, Index, IndexPacket, divmod, iced, make_esc, __iced_k, __iced_k_noop;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-utils').make_esc;

  C = require('./const');

  IndexPacket = require('./packet').IndexPacket;

  divmod = function(n, d) {
    return [Math.floor(n / d), n % d];
  };

  exports.Index = Index = (function() {
    function Index(_arg) {
      this.stubs = _arg.stubs, this.config = _arg.config;
      this._hmacs = [];
      this._empty_hash = new Buffer((function() {
        var _i, _ref, _results;
        _results = [];
        for (_i = 0, _ref = C.hmac.output_size; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
          _results.push(0);
        }
        return _results;
      })());
      this._dummy_blocks = {};
    }

    Index.prototype.index = function(_arg) {
      var hmac, index;
      index = _arg.index, hmac = _arg.hmac;
      return this._hmacs[index] = hmac;
    };

    Index.prototype.gen_dummy_block = function(len) {
      var ret;
      if ((ret = this._dummy_blocks[len]) == null) {
        ret = (function() {
          var _i, _results;
          _results = [];
          for (_i = 0; 0 <= len ? _i < len : _i > len; 0 <= len ? _i++ : _i--) {
            _results.push(this._empty_hash);
          }
          return _results;
        }).call(this);
        this._dummy_blocks[len] = ret;
      }
      return ret;
    };

    Index.prototype.gen_dummy = function(args, cb) {
      var esc, i, n, packets, t, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "HashIndex::gen_dummy");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
            funcname: "Index.gen_dummy"
          });
          _this.layout(esc(__iced_deferrals.defer({
            lineno: 39
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _i, _ref;
          n = _this._counts.file_blocks;
          t = _this._counts.total_blocks;
          for (i = _i = _ref = n - t; _ref <= n ? _i < n : _i > n; i = _ref <= n ? ++_i : --_i) {
            _this._hmacs[i] = _this._empty_hash;
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
              funcname: "Index.gen_dummy"
            });
            _this.generate({
              skip_sanity_check: true,
              clear: true
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return packets = arguments[0];
                };
              })(),
              lineno: 47
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null, packets);
          });
        };
      })(this));
    };

    Index.prototype.generate = function(args, cb) {
      var begin, end, esc, hpib, i, index, p, packets, pkt, prev, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "HashIndex::generate");
      (function(_this) {
        return (function(__iced_k) {
          if (!args.skip_sanity_check) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
                funcname: "Index.generate"
              });
              _this.sanity_check(esc(__iced_deferrals.defer({
                lineno: 54
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          prev = null;
          hpib = _this.config.hashes_per_block - 1;
          begin = _this._counts.total_blocks * hpib;
          end = _this._hmacs.length;
          i = _this._counts.interior_index_blocks;
          packets = [];
          (function(__iced_k) {
            var _results, _while;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(i > 0)) {
                return _break();
              } else {
                index = [];
                if (prev != null) {
                  index.push([i + 2, prev.get_hmac()]);
                }
                index.push([begin, _this._hmacs.slice(begin, end)]);
                end = begin;
                begin -= hpid;
                pkt = new IndexPacket({
                  index: index,
                  stubs: _this.stubs
                });
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
                    funcname: "Index.generate"
                  });
                  pkt.compute_hmac(esc(__iced_deferrals.defer({
                    lineno: 68
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  packets.push(pkt);
                  prev = pkt;
                  return _next(i--);
                });
              }
            };
            _while(__iced_k);
          })(function() {
            var _i, _len;
            packets.reverse();
            if (args.clear) {
              _this._hmacs = [];
            } else {
              for (i = _i = 0, _len = packets.length; _i < _len; i = ++_i) {
                p = packets[i];
                _this._hmacs[i + 1] = p;
              }
            }
            return cb(null, packets);
          });
        };
      })(this));
    };

    Index.prototype.do_last_packet = function(cb) {
      var err, i, index, pkt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      i = this._hmacs.length - this._counts.hashes_in_last_block;
      index = [i, this._hmacs.slice(i)];
      pkt = new IndexPacket({
        index: index,
        stubs: this.stubs
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
            funcname: "Index.do_last_packet"
          });
          pkt.compute_hmac(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 86
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, pkt);
        };
      })(this));
    };

    Index.prototype.sanity_check = function(cb) {
      var a, b, err, i, last, _i, _ref;
      err = null;
      if ((a = this._hmacs.length + 1) !== (b = this._counts.total_blocks)) {
        err = new Error("Wrong number of file blocks; wanted " + b + " but got " + a);
      } else {
        last = this._hmacs.length - 1;
        for (i = _i = 0, _ref = this._counts.file_blocks; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this._hmac[last - i] == null) {
            err = new Error("Missing file block at index " + (last - i));
            break;
          }
        }
      }
      return cb(err);
    };

    Index.prototype.layout = function(cb) {
      var esc, len, n_blocks, q, r, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "HashIndex::layout");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
            funcname: "Index.layout"
          });
          _this.stubs.get_length(esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return len = arguments[0];
              };
            })(),
            lineno: 107
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _ref;
          n_blocks = Math.ceil(len / _this.config.blocksize);
          _ref = divmod(n_blocks - 2, _this.config.hashes_per_block - 1), q = _ref[0], r = _ref[1];
          r += 2;
          _this._counts = {
            file_blocks: n_blocks,
            interior_index_blocks: q,
            index_blocks: q + 1,
            hashes_in_last_block: r,
            total_blocks: n_blocks + q + 1
          };
          return cb(null);
        };
      })(this));
    };

    return Index;

  })();

}).call(this);
