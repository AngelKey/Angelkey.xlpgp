// Generated by IcedCoffeeScript 1.7.1-f
(function() {
  var C, Index, IndexPacket, divmod, iced, make_esc, __iced_k, __iced_k_noop;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  C = require('./const');

  IndexPacket = require('./packet').IndexPacket;

  divmod = function(n, d) {
    return [Math.floor(n / d), n % d];
  };

  exports.Index = Index = (function() {
    function Index(_arg) {
      var i;
      this.stubs = _arg.stubs, this.config = _arg.config;
      this._hmacs = [];
      this._empty_hash = new Buffer((function() {
        var _i, _ref, _results;
        _results = [];
        for (_i = 0, _ref = C.hmac.output_size; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
          _results.push(0);
        }
        return _results;
      })());
      this._dummy_packet_data = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.config.hashes_per_index_packet; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this._empty_hash);
        }
        return _results;
      }).call(this);
      this._packets = {};
    }

    Index.prototype.index = function(_arg) {
      var hmac, index;
      index = _arg.index, hmac = _arg.hmac;
      return this._hmacs[index] = hmac;
    };

    Index.prototype.gen_dummy = function(_arg, cb) {
      var data, packetno, pkt;
      packetno = _arg.packetno;
      data = this._dummy_packet_data;
      pkt = new IndexPacket({
        packetno: packetno,
        data: data,
        stubs: this.stubs,
        dummy: this.dummy
      });
      this._packets[packetno] = pkt;
      return cb(null, pkt);
    };

    Index.prototype.gen_actual = function(_arg, cb) {
      var data, hpip, i, packet, packetno, val;
      packetno = _arg.packetno, packet = _arg.packet;
      hpip = this.config.hashes_per_index_packet;
      data = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= hpip ? _i < hpip : _i > hpip; i = 0 <= hpip ? ++_i : --_i) {
          val = this._hmacs[i + packetno + 1];
          if (val == null) {
            break;
          }
          _results.push(val);
        }
        return _results;
      }).call(this);
      packet.reset({
        data: data
      });
      return cb(null, packet);
    };

    Index.prototype.regen = function(cb) {
      var esc, packet, packetno, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Index::regen");
      (function(_this) {
        return (function(__iced_k) {
          var _i, _k, _keys, _ref, _results, _while;
          _ref = _this._packets;
          _keys = (function() {
            var _results1;
            _results1 = [];
            for (_k in _ref) {
              _results1.push(_k);
            }
            return _results1;
          })();
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _keys.length)) {
              return _break();
            } else {
              packetno = _keys[_i];
              packet = _ref[packetno];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
                  funcname: "Index.regen"
                });
                _this.gen_actual({
                  packetno: packetno,
                  packet: packet
                }, esc(__iced_deferrals.defer({
                  lineno: 52
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
                    funcname: "Index.regen"
                  });
                  packet.crypto(esc(__iced_deferrals.defer({
                    lineno: 53
                  })));
                  __iced_deferrals._fulfill();
                })(_next);
              });
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    Index.prototype.rewrite = function(_arg, cb) {
      var esc, packet, packet_writer, packetno, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      packet_writer = _arg.packet_writer;
      esc = make_esc(cb, "Index::rewrite");
      (function(_this) {
        return (function(__iced_k) {
          var _i, _k, _keys, _ref, _results, _while;
          _ref = _this._packets;
          _keys = (function() {
            var _results1;
            _results1 = [];
            for (_k in _ref) {
              _results1.push(_k);
            }
            return _results1;
          })();
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _keys.length)) {
              return _break();
            } else {
              packetno = _keys[_i];
              packet = _ref[packetno];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/xlpgp/src/index.iced",
                  funcname: "Index.rewrite"
                });
                packet_writer.write({
                  packet: packet,
                  offset: packet.get_offset()
                }, esc(__iced_deferrals.defer({
                  lineno: 61
                })));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    return Index;

  })();

}).call(this);
